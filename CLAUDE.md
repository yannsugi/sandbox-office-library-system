# CLAUDE.md

## üéØ Goal
Build a minimal **Internal Library Management REST API** with domains:
- User
- Book
- Division

Architecture constraints:
- Static dispatch (generics + `where` clauses)
- `PgConnection` and Diesel appear **only** in `repository_impl`
- Transaction boundary is **only** in Controller via a shared helper
- REST API returns JSON
- JSON DTO naming: **Jdto**

This is a mini app to reproduce architecture, not to optimize business features.

---

## ‚úÖ Minimal REST API
- POST /divisions
- POST /users
- POST /books
- GET /books
- GET /books/{id}
- POST /books/{id}/borrow
- POST /books/{id}/return

---

## üóÑ DB (Postgres / Diesel) - Minimal tables
- divisions: id SERIAL PK, name TEXT NOT NULL
- users: id SERIAL PK, name TEXT NOT NULL, division_id INT NOT NULL FK(divisions.id)
- books:
  - id SERIAL PK
  - title TEXT NOT NULL
  - division_id INT NOT NULL FK(divisions.id)
  - borrowed_by_user_id INT NULL FK(users.id)
  - borrowed_at TIMESTAMPTZ NULL

Keep it minimal (no loan history table).

---

## üèó Workspace layout (layer √ó context sub-crates)
<context> = {division, user, book}

backend/
- domain/
  - context/                       # PgConn trait, AppContext, TxContext
  - value_object/<context>/
  - entity_object/<context>/
  - collection_object/<context>/
- presenter/<context>/             # JSON DTO (Jdto)
- db_domain/<context>/             # Diesel schema.rs + models.rs
- repository/<context>/            # traits only
- repository_impl/<context>/       # struct + trait impl (Diesel)
- feature/<context>/               # trait + struct
- usecase/<context>/               # trait + struct
- controller/<context>/            # controller executes usecases within tx
- di_service/
- app/

Use lib.rs based crates.

---

## üîí Domain rules
Domain is split by type:
- value_object: Ids and validated primitives
- entity_object: entities
- collection_object: collections

Dependency rules:
- entity_object/<context> depends on value_object/<context>
- collection_object/<context> depends on entity_object/<context> + value_object/<context>
- value_object has no external deps

### Cross-domain references
Only allow referencing **other contexts' Id value objects**, not entities.
Examples:
- entity_object/book may depend on value_object/user and value_object/division (for UserId/DivisionId).
- entity_object/user may depend on value_object/division (for DivisionId).

Never reference db_domain or presenter from domain.

---

## üßæ Presenter (Jdto)
Each context has its own presenter crate.
Create minimal Jdto structs:

Division:
- CreateDivisionRequestJdto { name: String }
- DivisionResponseJdto { id: i32, name: String }

User:
- CreateUserRequestJdto { name: String, division_id: i32 }
- UserResponseJdto { id: i32, name: String, division_id: i32 }

Book:
- CreateBookRequestJdto { title: String, division_id: i32 }
- BookResponseJdto { id: i32, title: String, division_id: i32, borrowed_by_user_id: Option<i32> }
- BorrowBookRequestJdto { user_id: i32 }
- ReturnBookRequestJdto {} (empty body allowed)
- ErrorJdto { code: String, message: String }

Presenter must not depend on Diesel/db_domain.

---

## üóÑ db_domain (Diesel)
Each context has:
- schema.rs (generated by `diesel print-schema` with subschema configuration)
- models.rs (Queryable/Insertable DTOs)

Example:
db_domain/book/
- schema.rs  (table! for books)
- models.rs  (BookRow, NewBookRow, etc.)

db_domain must not depend on domain.

### Schema generation with Diesel subschema feature
Use `diesel.toml` subschema configuration to generate separate schema files:

```toml
# diesel.toml
[print_schema.division]
file = "db_domain/division/src/schema.rs"
filter = { only_tables = ["divisions"] }

[print_schema.user]
file = "db_domain/user/src/schema.rs"
filter = { only_tables = ["users"] }

[print_schema.book]
file = "db_domain/book/src/schema.rs"
filter = { only_tables = ["books"] }
```

Generate schemas:
```bash
# All domains at once (auto-detects from diesel.toml)
./scripts/generate-schemas.sh

# The script automatically finds all [print_schema.*] sections
# No manual updates needed when adding new domains!

# Or individually
diesel print-schema --schema-key division
diesel print-schema --schema-key user
diesel print-schema --schema-key book
```

---

## üß© Repository (traits only)
Define repository traits per context, generic over Ctx, passing `&mut Ctx`.
Do NOT mention PgConnection here.

Organize repository traits into CRUD (max 4 traits):
- RepoCreate<Ctx>
- RepoRead<Ctx>
- RepoUpdate<Ctx>
- RepoDelete<Ctx>

Examples:
Division:
- DivisionRepoCreate<Ctx>::create_division
- DivisionRepoRead<Ctx>::find_division

User:
- UserRepoCreate<Ctx>::create_user
- UserRepoRead<Ctx>::find_user

Book:
- BookRepoCreate<Ctx>::create_book
- BookRepoRead<Ctx>::find_book, list_books
- BookRepoUpdate<Ctx>::borrow_book, return_book

---

## üèó RepositoryImpl (Diesel only here)
For each context, create RepoImpl struct(s) and implement repository traits with `where Ctx: PgConn`:
- `impl<Ctx> Trait<Ctx> for RepoImpl where Ctx: PgConn`
- Use `ctx.conn()` to get `&mut PgConnection`

RepositoryImpl responsibilities:
- Diesel queries using PgConnection
- Mapping Domain <-> DbDomain DTO
- Do not leak db_domain types upward

Only repository_impl imports Diesel and db_domain.

---

## üß© Feature (trait + struct)
Feature struct holds RepoImpl via DI (`new()`).
Feature trait implementations use generics + where clauses only, do not mention PgConnection.

Pattern:
- struct XFeature<ARepo> { repo: ARepo }
- trait SomeFeature<Ctx> { fn execute(&self, ctx: &mut Ctx, ...) -> ... }
- impl<Ctx, ARepo> SomeFeature<Ctx> for XFeature<ARepo> where ARepo: RepoTrait<Ctx> { ... }

---

## üß© Usecase (trait + struct)
Usecase struct holds Feature struct.
Usecase trait implemented via generics + where clauses only.

Create minimal usecases:
Division:
- CreateDivisionUsecase
User:
- CreateUserUsecase
Book:
- CreateBookUsecase
- FindBookUsecase
- ListBooksUsecase
- BorrowBookUsecase
- ReturnBookUsecase

---

## üéÆ Controller (transaction boundary here only)
Controllers:
- Build DI structs directly (or via di_service)
- Wrap execution in shared `with_tx` helper
- Convert Jdto <-> Domain (Id conversion, validation for VO creation)
- Return JSON responses

### Shared transaction helper
Create a shared helper used by all controllers:
- acquire PgConnection from pool
- conn.transaction(|tx_conn| { ... })
- Create TxContext with AppContext + tx_conn
- call usecases with `&mut TxContext` as `&mut Ctx`

Use unified `executor` pattern to support various parameter patterns:
- `executor(&ctx, (), |conn, _| { ... })` - no params
- `executor(&ctx, req, |conn, req| { ... })` - single param
- `executor(&ctx, (*path, req), |conn, (path, req)| { ... })` - tuple params

No other layer starts transactions.

---

## ‚úÖ Deliverables
Generate compileable code for contexts {division, user, book}:
1) Domain crates (VO/entity/collection) with cross-id references allowed
2) Presenter Jdto crates
3) db_domain crates with schema.rs + models.rs
4) repository traits
5) repository_impl Diesel implementations
6) feature + usecase implementations using where clauses
7) controller endpoints with with_tx helper
8) app routing + main

Keep it minimal and consistent with these rules.

---

## üö´ Forbidden
- Diesel imports outside repository_impl
- PgConnection appears in feature/usecase/repository traits
- db_domain types used outside repository_impl
- Domain referencing presenter/db_domain/diesel
- Transactions started outside controller layer
